---
title: 7-20总结
tags:
  - 日记
  - diffusion model
  - 探索
categories: 随笔
status: 平淡
mathjax: true
abbrlink: c8297af
date: 2022-07-20 16:23:12
---

今日观赛：

- BLG打RNG：虽然是纯纯的打不过，但呼吸哥还是给了些机会，估计是有点想证明自己。

另外，今日阅读了IDDPM论文的官方开源代码，收获良多，主要学到以下几点新知识：

<!-- more -->

抽象类:

```python
from abc import ABC, abstractmethod #支持抽象类和抽象方法

声明class时继承ABC
class xxx(ABC):
  @abstractmethod #用修饰符说明是抽象方法
  def yyy(self):
    pass
  
class xxx_sun(xxx):
  #子类继承抽象类的话
  def yyy(self): #必须要实现每一个抽象方法
    print("ok")
```



枚举器：

```python
import enum
class ModelMeanType(enum.Enum):
    """
    继承一个枚举类基类的话
    """

    PREVIOUS_X = enum.auto()  #在里面声明一些名词
    START_X = enum.auto()  #enum.auto() 自动推断用什么作为枚举元(string,int之类的)
    EPSILON = enum.auto()  #
    def is_pr(self):
        return self == ModelMeanType.PREVIOUS_X #可以声明一些判别函数
      
target = {
   ModelMeanType.PREVIOUS_X: self.q_posterior_mean_variance(
   	x_start=x_start, x_t=x_t, t=t
   )[0],
   ModelMeanType.START_X: x_start,
   ModelMeanType.EPSILON: noise,
}[self.model_mean_type]
#后文可以直接用类似于一个Switch的方法，给不同的type声明不同的结果，然后按枚举器实际结果判别
```



字典式参数parser：

```python
def create_argparser():
    defaults = dict( #主函数中声明字典
        data_dir="",
        schedule_sampler="uniform",
        lr=1e-4,
    )
    defaults.update(model_and_diffusion_defaults()) #字典dict可以很方便的添加新元素
    parser = argparse.ArgumentParser()
    add_dict_to_argparser(parser, defaults)
    return parser
  
 def add_dict_to_argparser(parser, default_dict):
  	#add函数中把字典里所有元素进行遍历，一个一个加入argparser中
    for k, v in default_dict.items():
        v_type = type(v)
        if v is None:
            v_type = str
        elif isinstance(v, bool):
            v_type = str2bool
        parser.add_argument(f"--{k}", default=v, type=v_type)
```



函数传参单\*与双\*，他们都可以匹配参数个数、名字不确定的情况。

```python
def func(*args): #单*相当于把后面的内容解析成tuple
  							 #函数内部看做一个一个传进来的参数
    print(args)
    for i in args:
        print(i)
        
func(*[1, 2, 3])#如果在调用时传参前面加*，代表解一层递归，再传参
print("======")
func([1, 2, 3])

(1, 2, 3)
1
2
3
======
([1, 2, 3],)
[1, 2, 3]
```



```python
def func(**kwargs): #双星**代表把后面的看做一个dict
    print(kwargs)
    for k, v in kwargs.items():
        print(k, v)

func(**{'name':'Spade_', 'number':'888888'})
print("======")
func(name='Spade_', number='888888')

{'name': 'Spade_', 'number': '888888'}
name Spade_
number 888888
======
{'name': 'Spade_', 'number': '888888'}
name Spade_
number 888888
```

如果函数声明中有个单独的\*，就是一个分隔符，而不是参数，代表后面的参数在调用时都要以$x=100$这种形式写：

```python
def test_keyvalue(a,b,*,x,y=2,z=3):
    print(a,b,x,y,z)... 
test_keyvalue(1,2,3,4,5)
# Traceback (most recent call last):  File "", line 1, in TypeError: test_keyvalue() takes 2 positional arguments but 5 were given
test_keyvalue(1,2,x=3,y=4,z=5)
# 1 2 3 4 5
test_keyvalue(1,2,x=3)
# 1 2 3 2 3
test_keyvalue(1,2,x=3,z=8,y=9)
# 1 2 3 9 8
test_keyvalue(x=3,z=8,y=9,a=3,b=5)
# 3 5 3 9 8
```

